::: {.content-hidden unless-format="html"}
$$
\newcommand{\Exp}{\mathrm{E}}
\newcommand\given[1][]{\:#1\vert\:}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\rank}{\mathrm{rank}}
\newcommand{\bm}[1]{\boldsymbol{\mathbf{#1}}}
$$
:::


# Exercises I

### Required packages {.unnumbered}

```{r, message = FALSE, warning = FALSE, results = 'hide'}
pkgs <- c("sf", "mapview", "spdep", "spatialreg", "tmap", "viridisLite",
          "ggplot2", "ggthemes") # note: load spdep first, then spatialreg
lapply(pkgs, require, character.only = TRUE)

```

### Session info {.unnumbered}

```{r}
sessionInfo()

```

### Reload data from pervious session {.unnumbered}

```{r}
load("_data/msoa2_spatial.RData")
```



## General Exercises

### 1) Can you import the spatial administrative units of Germany ("Kreisgrenzen_2020_mit_Einwohnerzahl" in _data folder) and make a simple plot of the boundaries? {.unnumbered} 

```{r}
# Import shape file layer
ger.sdpf <- st_read(dsn = "_data/Kreisgrenzen_2020_mit_Einwohnerzahl",
                    layer = "KRS_ew_20")

# Plot via ggplot
gp <- ggplot(ger.sdpf)+
    geom_sf( color = "magenta", fill = NA)+
    coord_sf(datum = NA)+
    theme_map()
gp
```

### 2) What is the Coordinate reference system of this German shape file? {.unnumbered}

```{r}
st_crs(ger.sdpf)
```


### 3) Please use the msoa.spdf and calculate a neighbours weights matrix of the nearest 10 neighbours (see `spdep::knearneigh()`), and create a listw object using row normalization. {.unnumbered}

```{r}
coords <- st_centroid(msoa.spdf)
k10.nb <- knearneigh(coords, k = 10)
```

### 4) OPTIONAL: Can you create a map containing the City of London (MSOA11CD = "E02000001") and its ten nearest neighbours? {.unnumbered}

```{r}
i <- which(msoa.spdf$MSOA11CD == "E02000001")

# Extract neigbours
j <- k10.nb$nn[i,]

mapview(list(msoa.spdf[i,], msoa.spdf[j,]), col.regions = c("red", "blue"))
```


### 5) Please use the msoa.spdf and calculate a neighbours weights matrix of the nearest 10 neighbours (see `spdep::knearneigh()`), and create a listw object using row normalization. {.unnumbered}

```{r}
coords <- st_centroid(msoa.spdf)
k10.nb <- knearneigh(coords, k = 10)

### create nb object
k10.nb <- knn2nb(k10.nb)
summary(k10.nb)

### Create listw
k10.listw <- nb2listw(k10.nb, style = "W")
```


### 6) Please calculate the queens neighbours and make a listw object that includes the second order neighbours (see `nblag()`). {.unnumbered}

```{r}
# Queens neighbours
queens.nb <- poly2nb(msoa.spdf, queen = TRUE, snap = 1)
queens.listw <- nb2listw(queens.nb, style = "W")
```

```{r}
# Generate nb with 2 orders of neighbours
queens.lag <- nblag(queens.nb, maxlag = 2)

# Use the second element to create a listw object of second order neighbours
queens_second.listw <- nb2listw(queens.lag[[2]], style = "W")
```

### 7) Generate a matrix from the listw object {.unnumbered}

```{r}
queens.mat <- listw2mat(queens.listw)
queens.mat[1:10, 1:10]
```

### 8) What do you get when you multiply a variable (data column) such as the home owner rate with your weights matrix? {.unnumbered}

```{r}
# Summary of
summary(msoa.spdf$per_owner)

# Use matrix multiplication
lag.per_owner <- queens.mat %*% msoa.spdf$per_owner

# Summary of
summary(as.numeric(lag.per_owner))
```


