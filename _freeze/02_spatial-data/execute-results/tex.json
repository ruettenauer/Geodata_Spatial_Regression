{
  "hash": "1acbf4889ac454838bacc30ac973ab20",
  "result": {
    "markdown": "::: {.content-hidden unless-format=\"html\"}\n$$\n\\newcommand{\\tr}{\\mathrm{tr}}\n\\newcommand{\\rank}{\\mathrm{rank}}\n\\newcommand{\\plim}{\\operatornamewithlimits{plim}}\n\\newcommand{\\diag}{\\mathrm{diag}}\n\\newcommand{\\bm}[1]{\\boldsymbol{\\mathbf{#1}}}\n\\newcommand{\\Var}{\\mathrm{Var}}\n\\newcommand{\\Exp}{\\mathrm{E}}\n\\newcommand{\\Cov}{\\mathrm{Cov}}\n\\newcommand\\given[1][]{\\:#1\\vert\\:}\n\\newcommand{\\irow}[1]{%\n\\begin{pmatrix}#1\\end{pmatrix}\n}\n$$\n:::\n\n# Data Manipulation & Visualization\n\n### Required packages {.unnumbered}\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-1_a2095834d7b569395c84ab2dd13d8611'}\n\n```{.r .cell-code}\npkgs <- c(\"sf\", \"gstat\", \"mapview\", \"nngeo\", \"rnaturalearth\", \"dplyr\",\n          \"nomisr\", \"osmdata\", \"OpenStreetMap\", \"tidyr\", \"texreg\", \"downlit\", \"xml2\") \nlapply(pkgs, require, character.only = TRUE)\n```\n:::\n\n\n\nFor mapping\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-2_f777555ab316032837787af1004842b8'}\n\n```{.r .cell-code}\npkgs <- c(\"tmap\", \"tmaptools\", \"viridisLite\", \n          \"ggplot2\", \"ggthemes\", \"rmapshaper\", \"cowplot\") \nlapply(pkgs, require, character.only = TRUE)\n```\n:::\n\n\n\n### Session info {.unnumbered}\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-3_297e5d6d721034446bd9a5548c4bad57'}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.4.1 (2024-06-14 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United Kingdom.utf8 \n[2] LC_CTYPE=English_United Kingdom.utf8   \n[3] LC_MONETARY=English_United Kingdom.utf8\n[4] LC_NUMERIC=C                           \n[5] LC_TIME=English_United Kingdom.utf8    \n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] cowplot_1.1.3       rmapshaper_0.5.0    ggthemes_5.1.0     \n [4] ggplot2_3.5.1       viridisLite_0.4.2   tmaptools_3.1-1    \n [7] tmap_3.3-4          xml2_1.3.6          downlit_0.4.4      \n[10] texreg_1.39.3       tidyr_1.3.1         OpenStreetMap_0.4.0\n[13] osmdata_0.2.5       nomisr_0.4.7        dplyr_1.1.4        \n[16] rnaturalearth_1.0.1 nngeo_0.4.8         mapview_2.11.2     \n[19] gstat_2.1-1         sf_1.0-16          \n\nloaded via a namespace (and not attached):\n [1] tidyselect_1.2.1   fastmap_1.2.0      leaflet_2.2.2      XML_3.99-0.16.1   \n [5] digest_0.6.35      lifecycle_1.0.4    terra_1.7-78       magrittr_2.0.3    \n [9] compiler_4.4.1     rlang_1.1.4        tools_4.4.1        utf8_1.2.4        \n[13] rsdmx_0.6-3        data.table_1.15.4  knitr_1.47         FNN_1.1.4         \n[17] htmlwidgets_1.6.4  curl_5.2.1         sp_2.1-4           classInt_0.4-10   \n[21] plyr_1.8.9         RColorBrewer_1.1-3 abind_1.4-5        KernSmooth_2.23-24\n[25] withr_3.0.0        purrr_1.0.2        leafsync_0.1.0     grid_4.4.1        \n[29] stats4_4.4.1       fansi_1.0.6        xts_0.14.0         e1071_1.7-14      \n[33] leafem_0.2.3       colorspace_2.1-0   scales_1.3.0       dichromat_2.0-0.1 \n[37] cli_3.6.2          rmarkdown_2.27     intervals_0.15.4   generics_0.1.3    \n[41] rstudioapi_0.16.0  httr_1.4.7         DBI_1.2.3          cachem_1.1.0      \n[45] proxy_0.4-27       stringr_1.5.1      stars_0.6-5        parallel_4.4.1    \n[49] base64enc_0.1-3    vctrs_0.6.5        V8_4.4.2           jsonlite_1.8.8    \n[53] crosstalk_1.2.1    units_0.8-5        glue_1.7.0         lwgeom_0.2-14     \n[57] codetools_0.2-20   stringi_1.8.4      rJava_1.0-11       gtable_0.3.5      \n[61] raster_3.6-26      munsell_0.5.1      tibble_3.2.1       pillar_1.9.0      \n[65] htmltools_0.5.8.1  satellite_1.0.5    R6_2.5.1           evaluate_0.24.0   \n[69] lattice_0.22-6     png_0.1-8          memoise_2.0.1      snakecase_0.11.1  \n[73] class_7.3-22       Rcpp_1.0.12        spacetime_1.3-1    xfun_0.45         \n[77] zoo_1.8-12         pkgconfig_2.0.3   \n```\n:::\n:::\n\n\n\n### Reload data from pervious session {.unnumbered}\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-4_5dce7bb7342de313edc18649864d5dae'}\n\n```{.r .cell-code}\nload(\"_data/msoa_spatial.RData\")\nload(\"_data/ulez_spatial.RData\")\nload(\"_data/pollution_spatial.RData\")\nload(\"_data/pubs_spatial.RData\")\n```\n:::\n\n\n\n## Manipulation and linkage\n\nHaving data with geo-spatial information allows to perform a variety of methods to manipulate and link different data sources. Commonly used methods include 1) subsetting, 2) point-in-polygon operations, 3) distance measures, 4) intersections or buffer methods.\n\nThe [online Vignettes of the sf package](https://r-spatial.github.io/sf/articles/) provide a comprehensive overview of the multiple ways of spatial manipulations.\n\n#### Check if data is on common projection\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-5_72974dba7a1c19b38cc49926ac98f9ca'}\n\n```{.r .cell-code}\nst_crs(msoa.spdf) == st_crs(pol.spdf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nst_crs(msoa.spdf) == st_crs(pubs.spdf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nst_crs(msoa.spdf) == st_crs(ulez.spdf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n\nThe spatial data files are on different projections. Before we can do any spatial operations with them, we have to transform them into a common projection.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-6_94508cce6f74048c15a9d52d784f8d05'}\n\n```{.r .cell-code}\n# MSOA in different crs --> transform\npol.spdf <- st_transform(pol.spdf, crs = st_crs(msoa.spdf))\npubs.spdf <- st_transform(pubs.spdf, crs = st_crs(msoa.spdf))\nulez.spdf <- st_transform(ulez.spdf, crs = st_crs(msoa.spdf))\n\n\n# Check if all geometries are valid, and make valid if needed\nmsoa.spdf <- st_make_valid(msoa.spdf)\n```\n:::\n\n\n\nThe `st_make_valid()` function can help if the spatial geometries have some problems such as holes or points that don't match exactly.\n\n### Subsetting\n\nWe can subset spatial data in a similar way as we subset conventional data.frames or matrices. For instance, below we simply reduce the pollution grid across the UK to observations in London only.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-7_d093b45f168dc1150145ababa6c415ed'}\n\n```{.r .cell-code}\n# Subset to pollution estimates in London\npol_sub.spdf <- pol.spdf[msoa.spdf, ] # or:\npol_sub.spdf <- st_filter(pol.spdf, msoa.spdf)\nmapview(pol_sub.spdf)\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-7-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nOr we can reverse the above and exclude all intersecting units by specifying `st_disjoint` as alternative spatial operation using the `op =` option (note the empty space for column selection). `st_filter()` with the `.predicate` option does the same job. See the [sf Vignette](https://cran.r-project.org/web/packages/sf/vignettes/sf3.html) for more operations.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-8_7694ca744960716da90529bb8008d11f'}\n\n```{.r .cell-code}\n# Subset pubs to pubs not in the ulez area\nsub2.spdf <- pubs.spdf[ulez.spdf, , op = st_disjoint] # or:\nsub2.spdf <- st_filter(pubs.spdf, ulez.spdf, .predicate = st_disjoint)\nmapview(sub2.spdf)\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-8-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nWe can easily create indicators of whether an MSOA is within ulez or not.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-9_aa465d21217173c214fd6c53581dd6cf'}\n\n```{.r .cell-code}\nmsoa.spdf$ulez <- 0\n\n# intersecting lsoas\nwithin <- msoa.spdf[ulez.spdf,]\n\n# use their ids to create binary indicator \nmsoa.spdf$ulez[which(msoa.spdf$MSOA11CD %in% within$MSOA11CD)] <- 1\ntable(msoa.spdf$ulez)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  0   1 \n955  28 \n```\n:::\n:::\n\n\n\n### Point in polygon\n\nWe are interested in the number of pubs in each MSOA. So, we count the number of points in each polygon.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-10_b5e052729d9f9dcdc50ddbf66cfe03c9'}\n\n```{.r .cell-code}\n# Assign MSOA to each point\npubs_msoa.join <- st_join(pubs.spdf, msoa.spdf, join = st_within)\n\n# Count N by MSOA code (drop geometry to speed up)\npubs_msoa.join <- dplyr::count(st_drop_geometry(pubs_msoa.join),\n                               MSOA11CD = pubs_msoa.join$MSOA11CD,\n                               name = \"pubs_count\")\nsum(pubs_msoa.join$pubs_count)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1601\n```\n:::\n\n```{.r .cell-code}\n# Merge and replace NAs with zero (no matches, no pubs)\nmsoa.spdf <- merge(msoa.spdf, pubs_msoa.join,\n                   by = \"MSOA11CD\", all.x = TRUE)\nmsoa.spdf$pubs_count[is.na(msoa.spdf$pubs_count)] <- 0\n```\n:::\n\n\n\n\n### Distance measures\n\nWe might be interested in the distance to the nearest pub. Here, we use the package `nngeo` to find k nearest neighbours with the respective distance.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-11_b10c106c336c15082fecd7ca494f4eb5'}\n\n```{.r .cell-code}\n# Use geometric centroid of each MSOA\ncent.sp <- st_centroid(msoa.spdf[, \"MSOA11CD\"])\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: st_centroid assumes attributes are constant over geometries\n```\n:::\n\n```{.r .cell-code}\n# Get K nearest neighbour with distance\nknb.dist <- st_nn(cent.sp, \n                  pubs.spdf,\n                  k = 1,             # number of nearest neighbours\n                  returnDist = TRUE, # we also want the distance\n                  progress = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nprojected points\n```\n:::\n\n```{.r .cell-code}\nmsoa.spdf$dist_pubs <- unlist(knb.dist$dist)\nsummary(msoa.spdf$dist_pubs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n   9.079  305.149  565.018  701.961  948.047 3735.478 \n```\n:::\n:::\n\n\n\n### Intersections + Buffers\n\nWe may also want the average pollution within 1 km radius around each MSOA centroid. Note that it is usually better to use a ego-centric method where you calculate the average within a distance rather than using the characteristic of the intersecting cells only [@Lee.2008; @Mohai.2007].\n\nTherefore, we first create a buffer with `st_buffer()` around each midpoint and subsequently use `st_intersetion()` to calculate the overlap.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-12_75e062e8c42a1ba5cec07e56251ba0af'}\n\n```{.r .cell-code}\n# Create buffer (1km radius)\ncent.buf <- st_buffer(cent.sp, \n                      dist = 1000) # dist in meters\nmapview(cent.buf)\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-12-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# Add area of each buffer (in this constant) \ncent.buf$area <- as.numeric(st_area(cent.buf))\n\n# Calculate intersection of pollution grid and buffer\nint.df <- st_intersection(cent.buf, pol.spdf)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n```\n:::\n\n```{.r .cell-code}\nint.df$int_area <- as.numeric(st_area(int.df)) # area of intersection\n\n# Area of intersection as share of buffer\nint.df$area_per <- int.df$int_area / int.df$area\n```\n:::\n\n\n\nAnd we use the percent overlap areas as the weights to calculate a weighted mean.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-13_c3e6bd6c452ee07c4291526125a74c58'}\n\n```{.r .cell-code}\n# Aggregate as weighted mean\nint.df <- st_drop_geometry(int.df)\nint.df$no2_weighted <- int.df$no22011 * int.df$area_per\nint.df <- aggregate(list(no2 = int.df[, \"no2_weighted\"]), \n                    by = list(MSOA11CD = int.df$MSOA11CD),\n                    sum)\n\n# Merge back to spatial data.frame\nmsoa.spdf <- merge(msoa.spdf, int.df, by = \"MSOA11CD\", all.x = TRUE)\n\nmapview(msoa.spdf[, \"no2\"])\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-13-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nNote: for buffer related methods, it often makes sense to use population weighted centroids instead of geographic centroids (see [here](https://geoportal.statistics.gov.uk/datasets/ons::middle-layer-super-output-areas-december-2011-population-weighted-centroids/about) for MSOA population weighted centroids). However, often this information is not available.\n\n### and more\n\nThere are more spatial operation possible using sf. Have a look at the [sf Cheatsheet](fig/sf.pdf).\n\n![](fig/sf_1.png)\n\n\n### Air pollution and ethnic minorities\n\nWith a few lines of code, we have compiled an original dataset containing demographic information, air pollution, and some infrastructural information.\n\nLet's see what we can do with it.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-14_ff3d2ac1deef50deb378d1c0e26df4f7'}\n\n```{.r .cell-code}\n# Define ethnic group shares\nmsoa.spdf$per_mixed <- msoa.spdf$KS201EW_200 / msoa.spdf$KS201EW0001 * 100\nmsoa.spdf$per_asian <- msoa.spdf$KS201EW_300 / msoa.spdf$KS201EW0001 * 100\nmsoa.spdf$per_black <- msoa.spdf$KS201EW_400 / msoa.spdf$KS201EW0001 * 100\nmsoa.spdf$per_other <- msoa.spdf$KS201EW_500 / msoa.spdf$KS201EW0001 * 100\n\n# Define tenure\nmsoa.spdf$per_owner <- msoa.spdf$KS402EW_100 / msoa.spdf$KS402EW0001 * 100\nmsoa.spdf$per_social <- msoa.spdf$KS402EW_200 / msoa.spdf$KS402EW0001 * 100\n\n# Non British passport\nmsoa.spdf$per_nonUK <- (msoa.spdf$KS205EW0001 - msoa.spdf$KS205EW0003)/ msoa.spdf$KS205EW0001 * 100\nmsoa.spdf$per_nonEU <- (msoa.spdf$KS205EW0001 - msoa.spdf$KS205EW0003 -\n                          msoa.spdf$KS205EW0004 - msoa.spdf$KS205EW0005  - \n                          msoa.spdf$KS205EW0006)/ msoa.spdf$KS205EW0001 * 100\nmsoa.spdf$per_nonUK_EU <- (msoa.spdf$KS205EW0005  + msoa.spdf$KS205EW0006)/ msoa.spdf$KS205EW0001 * 100\n\n\n# Run regression\nmod1.lm <- lm(no2 ~ per_mixed + per_asian + per_black + per_other +\n                per_owner + per_social + pubs_count + POPDEN + ulez,\n              data = msoa.spdf)\n\n# summary\nscreenreg(list(mod1.lm), digits = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n========================\n             Model 1    \n------------------------\n(Intercept)   37.112 ***\n              (1.308)   \nper_mixed     -0.090    \n              (0.099)   \nper_asian      0.018 *  \n              (0.007)   \nper_black     -0.085 ***\n              (0.016)   \nper_other      0.462 ***\n              (0.047)   \nper_owner     -0.207 ***\n              (0.013)   \nper_social    -0.058 ***\n              (0.013)   \npubs_count     0.218 ***\n              (0.040)   \nPOPDEN         0.037 ***\n              (0.003)   \nulez           9.556 ***\n              (0.686)   \n------------------------\nR^2            0.774    \nAdj. R^2       0.772    \nNum. obs.    983        \n========================\n*** p < 0.001; ** p < 0.01; * p < 0.05\n```\n:::\n:::\n\n\n\nFor some examples later, we also add data on house prices. We use the median house prices in 2017 from the [London Datastore](https://data.london.gov.uk/dataset/average-house-prices).\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/house-prices_62cae1e0f51be04bac0afd5cba628ca8'}\n\n```{.r .cell-code}\n# Download\nhp.link <- \"https://data.london.gov.uk/download/average-house-prices/bdf8eee7-41e1-4d24-90ce-93fe5cf040ae/land-registry-house-prices-MSOA.csv\"\nhp.df <- read.csv(hp.link)\nhp.df <- hp.df[which(hp.df$Measure == \"Median\" &\n                       grepl(\"2011\", hp.df$Year)), ]\ntable(hp.df$Year)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nYear ending Dec 2011 Year ending Jun 2011 Year ending Mar 2011 \n                 983                  983                  983 \nYear ending Sep 2011 \n                 983 \n```\n:::\n\n```{.r .cell-code}\n# Aggregate across 2011 values\nhp.df$med_house_price <- as.numeric(hp.df$Value)\nhp.df <- aggregate(hp.df[, \"med_house_price\", drop = FALSE],\n                   by = list(MSOA11CD = hp.df$Code),\n                   FUN = function(x) mean(x, na.rm = TRUE))\n\n# Merge spdf and housing prices\nmsoa.spdf <- merge(msoa.spdf, hp.df,\n                   by = \"MSOA11CD\",\n                   all.x = TRUE, all.y = FALSE)\nhist(log(msoa.spdf$med_house_price))\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/house-prices-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n### Save spatial data\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-15_d7086daa1c5f4540429db2d7060698de'}\n\n```{.r .cell-code}\n# Save\nsave(msoa.spdf, file = \"_data/msoa2_spatial.RData\")\n```\n:::\n\n\n\n\n\n\n## Visualization\n\nA large advantage of spatial data is that different data sources can be connected and combined. Another nice advantage is: you can create very nice maps. And it's quite easy to do! [Stefan JÃ¼nger](https://stefanjuenger.github.io/) & [Anne-Kathrin Stroppe](https://www.gesis.org/institut/mitarbeitendenverzeichnis/person/Anne-Kathrin.Stroppe) provide more comprehensive materials on mapping in their [GESIS workshop on geospatial techniques in R](https://github.com/StefanJuenger/gesis-workshop-geospatial-techniques-R-2023).\n\nMany packages and functions can be used to plot maps of spatial data. For instance, ggplot as a function to plot spatial data using `geom_sf()`. I am personally a fan of `tmap`, which makes many steps easier (but sometimes is less flexible).\n\nA great tool for choosing coulour is for instance [Colorbrewer](https://colorbrewer2.org/). `viridisLite` provides another great resource to chose colours.\n\n### Tmaps\n\nFor instance, lets plot the NO2 estimates using tmap + `tm_fill()` (there are lots of alternatives like `tm_shape`, `tm_points()`, `tm_dots()`).\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-16_26e4941c7c7a0ea0537c89f6e724cdc1'}\n\n```{.r .cell-code}\n# Define colours\ncols <- viridis(n = 7, direction = 1, option = \"C\")\n\nmp1 <-  tm_shape(msoa.spdf) + \n  tm_fill(col = \"no2\", \n          style = \"fisher\", # algorithm to def cut points\n          n = 7, # Number of requested cut points\n          palette = cols, # colours\n          alpha = 1, # transparency \n          title = \"NO2\", \n          legend.hist = FALSE # histogram next to map?\n          ) +\n  tm_borders(col = \"white\", lwd = 0.5, alpha = 0.5) \n\nmp1\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-16-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nTmap allows to easily combine different objects by defining a new object via `tm_shape()`.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-17_e752128bcda9942f9d37fe8c791d851e'}\n\n```{.r .cell-code}\n# Define colours\ncols <- viridis(n = 7, direction = 1, option = \"C\")\n\nmp1 <-  tm_shape(msoa.spdf) + \n  tm_fill(col = \"no2\", \n          style = \"fisher\", # algorithm to def cut points\n          n = 7, # Number of requested cut points\n          palette = cols, # colours\n          alpha = 1, # transparency \n          title = \"NO2\", \n          legend.hist = FALSE # histogram next to map?\n          ) +\n  tm_borders(col = \"white\", lwd = 0.5, alpha = 0.5) +\n  tm_shape(ulez.spdf) +\n  tm_borders(col = \"red\", lwd = 1, alpha = 1) \n\nmp1\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-17-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nAnd it is easy to change the layout.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-18_93e7002d61f380e9a7a49d68d7278af6'}\n\n```{.r .cell-code}\n# Define colours\ncols <- viridis(n = 7, direction = 1, option = \"C\")\n\nmp1 <-  tm_shape(msoa.spdf) + \n  tm_fill(col = \"no2\", \n          style = \"fisher\", # algorithm to def cut points\n          n = 7, # Number of requested cut points\n          palette = cols, # colours\n          alpha = 1, # transparency \n          title = expression('in'~mu*'g'/m^{3}), \n          legend.hist = FALSE # histogram next to map?\n          ) +\n  tm_borders(col = \"white\", lwd = 0.5, alpha = 0.5) +\n  tm_shape(ulez.spdf) +\n  tm_borders(col = \"red\", lwd = 1, alpha = 1) +\n  tm_layout(frame = FALSE,\n            legend.frame = TRUE, legend.bg.color = TRUE,\n            legend.position = c(\"right\", \"bottom\"),\n            legend.outside = FALSE,\n            main.title = \"NO2\", \n            main.title.position = \"center\",\n            main.title.size = 1.6,\n            legend.title.size = 0.8,\n            legend.text.size = 0.8)\n\nmp1\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-18-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\nWe can also add some map information from OSM. However, it's sometimes a bit tricky with the projection. That's why we switch into the OSM projection here. Note that this osm query is build on retiring packages.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-19_2e97fb97c857124c56f5a4a68a9c79bb'}\n\n```{.r .cell-code}\n# Save old projection\ncrs_orig <- st_crs(msoa.spdf)\n\n# Change projection\nulez.spdf <- st_transform(ulez.spdf, 4326)\nmsoa.spdf <- st_transform(msoa.spdf, 4326)\n\n# Get OSM data for background\nosm_tmp <- read_osm(st_bbox(msoa.spdf), ext = 1.1, type = \"osm-german\") \n\n# Define colours\ncols <- viridis(n = 7, direction = 1, option = \"C\")\n\nmp1 <-  tm_shape(osm_tmp) + tm_rgb() +\n  tm_shape(msoa.spdf) + \n  tm_fill(col = \"no2\", \n          style = \"fisher\", # algorithm to def cut points\n          n = 7, # Number of requested cut points\n          palette = cols, # colours\n          alpha = 0.8, # transparency \n          title = expression('in'~mu*'g'/m^{3}), \n          legend.hist = FALSE # histogram next to map?\n          ) +\n  #tm_borders(col = \"white\", lwd = 0.5, alpha = 0.5) +\n  tm_shape(ulez.spdf) +\n  tm_borders(col = \"red\", lwd = 1, alpha = 1) +\n  tm_layout(frame = FALSE,\n            legend.frame = TRUE, legend.bg.color = TRUE,\n            legend.position = c(\"right\", \"bottom\"),\n            legend.outside = FALSE,\n            main.title = \"NO2\", \n            main.title.position = \"center\",\n            main.title.size = 1.6,\n            legend.title.size = 0.8,\n            legend.text.size = 0.8)\n\nmp1\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-19-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nTmap also makes it easy to combine single maps\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-20_2479787307dfa9f0836d085fb056abcb'}\n\n```{.r .cell-code}\n# Define colours\ncols1 <- viridis(n = 7, direction = 1, option = \"C\")\n\n# Define colours\ncols2 <- viridis(n = 7, direction = 1, option = \"D\")\n\nmp1 <-  tm_shape(osm_tmp) + tm_rgb() +\n  tm_shape(msoa.spdf) + \n  tm_fill(col = \"no2\", \n          style = \"fisher\", # algorithm to def cut points\n          n = 7, # Number of requested cut points\n          palette = cols1, # colours\n          alpha = 0.8, # transparency \n          title = expression('in'~mu*'g'/m^{3}), \n          legend.hist = FALSE # histogram next to map?\n          ) +\n  #tm_borders(col = \"white\", lwd = 0.5, alpha = 0.5) +\n  tm_shape(ulez.spdf) +\n  tm_borders(col = \"red\", lwd = 1, alpha = 1) +\n  tm_layout(frame = FALSE,\n            legend.frame = TRUE, legend.bg.color = TRUE,\n            legend.position = c(\"right\", \"bottom\"),\n            legend.outside = FALSE,\n            main.title = \"NO2\", \n            main.title.position = \"center\",\n            main.title.size = 1.4,\n            legend.title.size = 0.8,\n            legend.text.size = 0.8)\n\nmp2 <-  tm_shape(osm_tmp) + tm_rgb() +\n  tm_shape(msoa.spdf) + \n  tm_fill(col = \"per_black\", \n          style = \"fisher\", # algorithm to def cut points\n          n = 7, # Number of requested cut points\n          palette = cols2, # colours\n          alpha = 0.8, # transparency \n          title = \"% white\", \n          legend.hist = FALSE # histogram next to map?\n          ) +\n  #tm_borders(col = \"white\", lwd = 0.5, alpha = 0.5) +\n  tm_shape(ulez.spdf) +\n  tm_borders(col = \"red\", lwd = 1, alpha = 1) +\n  tm_layout(frame = FALSE,\n            legend.frame = TRUE, legend.bg.color = TRUE,\n            legend.position = c(\"right\", \"bottom\"),\n            legend.outside = FALSE,\n            main.title = \"Ethnic Black inhabitants\", \n            main.title.position = \"center\",\n            main.title.size = 1.4,\n            legend.title.size = 0.8,\n            legend.text.size = 0.8)\n\ntmap_arrange(mp1, mp2, ncol = 2, nrow = 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLegend labels were too wide. The labels have been resized to 0.63, 0.63, 0.63, 0.63, 0.63, 0.63, 0.63. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nSome legend labels were too wide. These labels have been resized to 0.68, 0.63, 0.63, 0.63, 0.63. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\n```\n:::\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-20-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nAnd you can easily export those to png or pdf\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-21_0b8293c1202686781423b5d2bd17761b'}\n\n```{.r .cell-code}\npng(file = paste(\"London.png\", sep = \"\"), width = 14, height = 7, units = \"in\", \n    res = 100, bg = \"white\")\npar(mar=c(0,0,3,0))\npar(mfrow=c(1,1),oma=c(0,0,0,0))\ntmap_arrange(mp1, mp2, ncol = 2, nrow = 1)\ndev.off()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npdf \n  2 \n```\n:::\n:::\n\n\n\n### ggplot\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-22_730ab420e0083f69df3f4acbcf96321e'}\n\n```{.r .cell-code}\ngp <- ggplot(msoa.spdf)+\n    geom_sf(aes(fill = no2))+\n    scale_fill_viridis_c(option = \"B\")+\n    coord_sf(datum = NA)+\n    theme_map()+\n    theme(legend.position = c(.9, .6))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2\n3.5.0.\ni Please use the `legend.position.inside` argument of `theme()` instead.\n```\n:::\n\n```{.r .cell-code}\ngp\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-22-1.pdf){fig-pos='H'}\n:::\n:::\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-23_e18788cdc63457a43b80a71766e021c8'}\n\n```{.r .cell-code}\n# Get some larger scale boundaries\nborough.spdf <- st_read(dsn = paste0(\"_data\", \"/statistical-gis-boundaries-london/ESRI\"),\n                     layer = \"London_Borough_Excluding_MHW\" # Note: no file ending\n                     )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `London_Borough_Excluding_MHW' from data source \n  `C:\\work\\Lehre\\Geodata_Spatial_Regression\\_data\\statistical-gis-boundaries-london\\ESRI' \n  using driver `ESRI Shapefile'\nSimple feature collection with 33 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 503568.2 ymin: 155850.8 xmax: 561957.5 ymax: 200933.9\nProjected CRS: OSGB36 / British National Grid\n```\n:::\n\n```{.r .cell-code}\n# transform to only inner lines\nborough_inner <- ms_innerlines(borough.spdf)\n\n# Plot with inner lines\ngp <- ggplot(msoa.spdf)+\n    geom_sf(aes(fill = no2), color = NA)+\n    scale_fill_viridis_c(option = \"A\")+\n    geom_sf(data = borough_inner, color = \"gray92\")+\n    geom_sf(data = ulez.spdf, color = \"red\", fill = NA)+\n    coord_sf(datum = NA)+\n    theme_map()+\n    labs(fill = \"NO2\")+\n    theme(legend.position = c(.9, .6))\ngp\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-23-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n## Exercises\n\n1) What is the difference between a spatial \"sf\" object and a conventional \"data.frame\"? What's the purpose of the function `st_drop_geometry()`?\n\nIt's the same. A spatial \"sf\" object just has an additional column containing the spatial coordinates.\n\n2) Using msoa.spdf, please create a spatial data frame that contains only the MSOA areas that are within the ulez zone.\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-24_ba4ad49a5bcea537afc1823d36e64d85'}\n\n```{.r .cell-code}\nsub4.spdf <- msoa.spdf[ulez.spdf, ]\n```\n:::\n\n\n\n\n3) Please create a map for London (or only the msoa-ulez subset) which shows the share of Asian residents (or any other ethnic group).\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-25_43631da567f3a04b4d12bcafe7f1754a'}\n\n```{.r .cell-code}\ngp <- ggplot(msoa.spdf)+\n    geom_sf(aes(fill = per_asian))+\n    scale_fill_viridis_c(option = \"E\")+\n    coord_sf(datum = NA)+\n    theme_map()+\n    theme(legend.position = c(.9, .6))\ngp\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-25-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n\n4) Please calculate the distance of each MSOA to the London city centre \n  a) use google maps to get lon and lat, \n  b) use `st_as_sf()` to create the spatial point\n  c) use `st_distance()` to calculate the distance\n  \n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-26_7643ad84caac59a2f436113df677ab43'}\n\n```{.r .cell-code}\n### Distance to city center\n# Define centre\ncentre <- st_as_sf(data.frame(lon = -0.128120855701165, \n                              lat = 51.50725909644806),\n                   coords = c(\"lon\", \"lat\"), \n                   crs = 4326)\n# Reproject\ncentre <- st_transform(centre, crs = st_crs(msoa.spdf))\n# Calculate distance\nmsoa.spdf$dist_centre <- as.numeric(st_distance(msoa.spdf, centre)) / 1000\n# hist(msoa.spdf$dist_centre)\n```\n:::\n\n\n  \n  \n5) Can you create a plot with the distance to the city centre and pub counts next to each other?  \n\n\n\n\n::: {.cell hash='02_spatial-data_cache/pdf/unnamed-chunk-27_4ca000fe9a9debcd0f5baf1845b75c6f'}\n\n```{.r .cell-code}\n# Define colours\ncols <- viridis(n = 10, direction = 1, option = \"B\")\ncols2 <- viridis(n = 10, direction = 1, option = \"E\")\n\n\nmp1 <-  tm_shape(msoa.spdf) + \n  tm_fill(col = \"dist_centre\", \n          style = \"fisher\", # algorithm to def cut points\n          n = 10, # Number of requested cut points\n          palette = cols, # colours\n          alpha = 1, # transparency \n          title = \"Distance\", \n          legend.hist = FALSE # histogram next to map?\n          ) +\n  tm_borders(col = \"white\", lwd = 0.5, alpha = 0.5) +\n  tm_layout(frame = FALSE,\n            legend.frame = TRUE, legend.bg.color = TRUE,\n            legend.position = c(\"right\", \"bottom\"),\n            legend.outside = FALSE,\n            main.title = \"Dist centre\", \n            main.title.position = \"center\",\n            main.title.size = 1.6,\n            legend.title.size = 0.8,\n            legend.text.size = 0.8)\n\n\nmp2 <-  tm_shape(msoa.spdf) + \n  tm_fill(col = \"dist_centre\", \n          style = \"quantile\", # algorithm to def cut points\n          n = 10, # Number of requested cut points\n          palette = cols, # colours\n          alpha = 1, # transparency \n          title = \"Distance\", \n          legend.hist = FALSE # histogram next to map?\n          ) +\n  tm_borders(col = \"white\", lwd = 0.5, alpha = 0.5) +\n  tm_layout(frame = FALSE,\n            legend.frame = TRUE, legend.bg.color = TRUE,\n            legend.position = c(\"right\", \"bottom\"),\n            legend.outside = FALSE,\n            main.title = \"Dist centre\", \n            main.title.position = \"center\",\n            main.title.size = 1.6,\n            legend.title.size = 0.8,\n            legend.text.size = 0.8)\n\n\nmp3 <-  tm_shape(msoa.spdf) + \n  tm_fill(col = \"pubs_count\", \n          style = \"fisher\", # algorithm to def cut points\n          n = 10, # Number of requested cut points\n          palette = cols, # colours\n          alpha = 1, # transparency \n          title = \"Count\", \n          legend.hist = FALSE # histogram next to map?\n          ) +\n  tm_borders(col = \"white\", lwd = 0.5, alpha = 0.5) +\n  tm_layout(frame = FALSE,\n            legend.frame = TRUE, legend.bg.color = TRUE,\n            legend.position = c(\"right\", \"bottom\"),\n            legend.outside = FALSE,\n            main.title = \"Pubs\", \n            main.title.position = \"center\",\n            main.title.size = 1.6,\n            legend.title.size = 0.8,\n            legend.text.size = 0.8)\n\n\nmp4 <-  tm_shape(msoa.spdf) + \n  tm_fill(col = \"pubs_count\", \n          style = \"quantile\", # algorithm to def cut points\n          n = 10, # Number of requested cut points\n          palette = cols, # colours\n          alpha = 1, # transparency \n          title = \"Count\", \n          legend.hist = FALSE # histogram next to map?\n          ) +\n  tm_borders(col = \"white\", lwd = 0.5, alpha = 0.5) +\n  tm_layout(frame = FALSE,\n            legend.frame = TRUE, legend.bg.color = TRUE,\n            legend.position = c(\"right\", \"bottom\"),\n            legend.outside = FALSE,\n            main.title = \"Pubs\", \n            main.title.position = \"center\",\n            main.title.size = 1.6,\n            legend.title.size = 0.8,\n            legend.text.size = 0.8)\n\n\ntmap_arrange(mp1, mp2, mp3, mp4, ncol = 2, nrow = 2)\n```\n\n::: {.cell-output-display}\n![](02_spatial-data_files/figure-pdf/unnamed-chunk-27-1.pdf){fig-pos='H'}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}