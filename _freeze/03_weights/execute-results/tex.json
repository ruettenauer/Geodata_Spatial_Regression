{
  "hash": "7753807a2870be54e03e0ad2356893a9",
  "result": {
    "markdown": "::: {.content-hidden unless-format=\"html\"}\n$$\n\\newcommand{\\tr}{\\mathrm{tr}}\n\\newcommand{\\rank}{\\mathrm{rank}}\n\\newcommand{\\plim}{\\operatornamewithlimits{plim}}\n\\newcommand{\\diag}{\\mathrm{diag}}\n\\newcommand{\\bm}[1]{\\boldsymbol{\\mathbf{#1}}}\n\\newcommand{\\Var}{\\mathrm{Var}}\n\\newcommand{\\Exp}{\\mathrm{E}}\n\\newcommand{\\Cov}{\\mathrm{Cov}}\n\\newcommand\\given[1][]{\\:#1\\vert\\:}\n\\newcommand{\\irow}[1]{%\n\\begin{pmatrix}#1\\end{pmatrix}\n}\n$$\n:::\n\n# Spatial Relationships W\n\n### Required packages {.unnumbered}\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-1_c256b5a5abacffaa54cf5a2b18089a62'}\n\n```{.r .cell-code}\npkgs <- c(\"sf\", \"mapview\", \"spdep\", \"spatialreg\", \"tmap\", \"viridisLite\") # note: load spdep first, then spatialreg\nlapply(pkgs, require, character.only = TRUE)\n```\n:::\n\n\n\n### Session info {.unnumbered}\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-2_68d253132f09e389d0c3265d6761d533'}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.4.1 (2024-06-14 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United Kingdom.utf8 \n[2] LC_CTYPE=English_United Kingdom.utf8   \n[3] LC_MONETARY=English_United Kingdom.utf8\n[4] LC_NUMERIC=C                           \n[5] LC_TIME=English_United Kingdom.utf8    \n\ntime zone: Europe/Berlin\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] viridisLite_0.4.2 tmap_3.3-4        spatialreg_1.3-4  Matrix_1.7-0     \n[5] spdep_1.3-5       spData_2.3.1      mapview_2.11.2    sf_1.0-16        \n\nloaded via a namespace (and not attached):\n [1] xfun_0.45          raster_3.6-26      htmlwidgets_1.6.4  lattice_0.22-6    \n [5] tools_4.4.1        crosstalk_1.2.1    LearnBayes_2.15.1  parallel_4.4.1    \n [9] stats4_4.4.1       sandwich_3.1-0     proxy_0.4-27       KernSmooth_2.23-24\n[13] satellite_1.0.5    RColorBrewer_1.1-3 leaflet_2.2.2      lifecycle_1.0.4   \n[17] compiler_4.4.1     deldir_2.0-4       munsell_0.5.1      terra_1.7-78      \n[21] codetools_0.2-20   leafsync_0.1.0     stars_0.6-5        htmltools_0.5.8.1 \n[25] class_7.3-22       MASS_7.3-60.2      classInt_0.4-10    lwgeom_0.2-14     \n[29] wk_0.9.1           abind_1.4-5        boot_1.3-30        multcomp_1.4-25   \n[33] nlme_3.1-164       digest_0.6.35      mvtnorm_1.2-5      splines_4.4.1     \n[37] fastmap_1.2.0      grid_4.4.1         colorspace_2.1-0   cli_3.6.2         \n[41] magrittr_2.0.3     base64enc_0.1-3    dichromat_2.0-0.1  XML_3.99-0.16.1   \n[45] survival_3.6-4     leafem_0.2.3       TH.data_1.1-2      e1071_1.7-14      \n[49] scales_1.3.0       sp_2.1-4           rmarkdown_2.27     zoo_1.8-12        \n[53] png_0.1-8          coda_0.19-4.1      evaluate_0.24.0    knitr_1.47        \n[57] tmaptools_3.1-1    s2_1.1.6           rlang_1.1.4        Rcpp_1.0.12       \n[61] glue_1.7.0         DBI_1.2.3          rstudioapi_0.16.0  jsonlite_1.8.8    \n[65] R6_2.5.1           units_0.8-5       \n```\n:::\n:::\n\n\n\n### Reload data from pervious session {.unnumbered}\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-3_457a11f757d42c846f9e513e3a1720fa'}\n\n```{.r .cell-code}\nload(\"_data/msoa2_spatial.RData\")\n```\n:::\n\n\n\n## Spatial interdependence\n\nWe can not only use coordinates and geo-spatial information to connect different data sources, we can also explicitly model spatial (inter)dependence in the analysis of our data. In many instance, accounting for spatial dependence might even be necessary to avoid biased point estimates and standard errors, as observations are often not independent and identically distributed.\n\nTobler's first law of geography has been used extensively (11,584 citation in 2023-06) to describe spatial dependence: 'Everything is related to everything else, but near things are more related than distant things' [@Tobler.1970].\n\n::: callout-note\nTobler's first law is a bit of story\n\nAnd it has been labeled as an excuse to not think too much about the reasons for spatial dependence or auto-correlation. For instance, measurement error, omitted variables, or inappropriate levels of aggregation are among reasons for auto-correlation [@Pebesma.2023].\n:::\n\nWe will come back to the reasons of spatial dependence. However, for now, we are interested in some tools to detect and analyse spatial relations.\n\nTo analyse spatial relations, we first need to define some sort of connectivity between units (e.g. similar to network analysis). There are some obvious candidates that be used to define these relations here: adjacency and proximity.\n\n## $\\bm W$: Connectivity between units\n\nThe connectivity between units is usually represented in a matrix $\\bm W$. There is an ongoing debate about the importance of spatial weights for spatial econometrics and about the right way to specify weights matrices [@LeSage.2014a; @Neumayer.2016]. The following graph shows some possible options in how to define connectivity between units.\n\n![Figure: Different measures of connectivity, Source: @Bivand.2018](fig/Bivand_neighbours.png)\n\nIn spatial econometrics, the spatial connectivity (as shown above) is usually represented by a spatial weights matrix ${\\boldsymbol{\\mathbf{W}}}$: \n\n$$\n\\boldsymbol{\\mathbf{W}} = \\begin{bmatrix} \n    w_{11} & w_{12} & \\dots & w_{1n} \\\\\n    w_{21} & w_{22} & \\dots & w_{2n} \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    w_{n1} & w_{n2} & \\dots     & w_{nn} \n    \\end{bmatrix}\n$$ \n\nThe spatial weights matrix $\\bm W$ is an $N \\times N$ dimensional matrix with elements $w_{ij}$ specifying the relation or connectivity between each pair of units $i$ and $j$.\n\nNote: The diagonal elements $w_{i,i}= w_{1,1}, w_{2,2}, \\dots, w_{n,n}$ of $\\bm W$ are always zero. No unit is a neighbour of itself. This is not true for spatial multiplier matrices (as we will see later).\n\n### Contiguity weights\n\nA very common type of spatial weights. Binary specification, taking the value 1 for neighbouring units (queens: sharing a common edge; rook: sharing a common border), and 0 otherwise.\n\nContiguity weights $w_{i,j}$, where\n\n$$\n  w_{i,j} =\n    \\begin{cases}\n      1 & \\text{if $i$ and $j$ neighbours}\\\\\n      0 & \\text{otherwise}\n    \\end{cases}       \n$$\n\nA contiguity weights matrix with three units, where unit 1 and unit 3 are neighbours, while unit 2 has no neighbours would look like this:\n\n$$\n\\boldsymbol{\\mathbf{W}}  = \\begin{bmatrix} \n    0 & 0 & 1  \\\\\n    0 & 0 & 0  \\\\\n    1 & 0 & 0  \n    \\end{bmatrix}   \\nonumber\n$$\n\n-   Sparse matrices\n\n-   Problem of \\`island': units without neighbours (if I calculate an average of their neigbours, would that be zero, or NA, or a mean?)\n\nLets create a contiguity weights matrix (Queens neighbours) for the London MSOAs: we create a neighbours list (`nb`) using `poly2nb()`, which is an efficient way of storing ${\\boldsymbol{\\mathbf{W}}}$. A `snap` of 1 meter accounts for potential lacks of accuracy between lines and points.\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-4_ec7162d24c031dabe8ed444ac00e9b7e'}\n\n```{.r .cell-code}\n# Contiguity (Queens) neighbours weights\nqueens.nb <- poly2nb(msoa.spdf, \n                     queen = TRUE, # a single shared boundary point meets the contiguity condition\n                     snap = 1) # we consider points in 1m distance as 'touching'\nsummary(queens.nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 983 \nNumber of nonzero links: 5648 \nPercentage nonzero weights: 0.5845042 \nAverage number of links: 5.745677 \nLink number distribution:\n\n  2   3   4   5   6   7   8   9  10  11  12  13 \n  9  39 130 264 273 169  66  19   5   6   2   1 \n9 least connected regions:\n160 270 475 490 597 729 755 778 861 with 2 links\n1 most connected region:\n946 with 13 links\n```\n:::\n\n```{.r .cell-code}\n# Lets plot that\nplot(st_geometry(msoa.spdf), border = \"grey60\")\nplot(queens.nb, st_centroid(st_geometry(msoa.spdf)), \n     add = TRUE, pch = 19, cex = 0.6)\n```\n\n::: {.cell-output-display}\n![](03_weights_files/figure-pdf/unnamed-chunk-4-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# We can also transform this into a matrix W\nW <- nb2mat(queens.nb, style = \"B\")\nprint(W[1:10, 1:10])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n1     0    0    0    0    0    0    0    0    0     0\n2     0    0    1    0    0    0    0    0    0     0\n3     0    1    0    0    1    0    0    0    0     0\n4     0    0    0    0    0    1    0    0    0     1\n5     0    0    1    0    0    1    1    0    0     0\n6     0    0    0    1    1    0    1    0    1     1\n7     0    0    0    0    1    1    0    1    1     0\n8     0    0    0    0    0    0    1    0    0     0\n9     0    0    0    0    0    1    1    0    0     1\n10    0    0    0    1    0    1    0    0    1     0\n```\n:::\n:::\n\n\n\n::: callout-tip\n## Question\n\nAmong those first 10 units that you see above, which are the neighbours of unit number 6?\n\nWhy is the diagonal of this matrix all zero?\n:::\n\nOverall, the matrix W has dimensions $N \\times N$, a row and a column for each observation. The value in a cell shows how units $i$ (row number) and $j$ (column number) are related to each other.\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-5_f8a0189ee71c61b589477e3a55f0f673'}\n\n```{.r .cell-code}\ndim(W)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 983 983\n```\n:::\n:::\n\n\n\nThe row and column sums indicate the number of neighbours of each observation.\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-6_0d68f4494ee67254e0f6433f8045d95b'}\n\n```{.r .cell-code}\nrowSums(W)[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n 1  2  3  4  5  6  7  8  9 10 \n11  6  7  5  5  6  6  6  6  5 \n```\n:::\n\n```{.r .cell-code}\ncolSums(W)[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 11  6  7  5  5  6  6  6  6  5\n```\n:::\n:::\n\n\n\nAdjacency or graph-based neighbour's weights matrices are usually symmetric. If unit 1 is a neighbour of unit 55, then unit 55 is also a neighbour of unit 1.\n\n\n::: callout-tip\n## Higher Order Neighbours\n\nYour neighbours have neighbours too, and they are called higher (second) order neighbours. The neighbours of your neighbour's neighbours are third order neighbours.\n\nYou can use `nblag()` to calculate higher order neighbour relations.\n:::\n\n\n\n### Distance based weights\n\nAnother common type uses the distance $d_{ij}$ between each unit $i$ and $j$.\n\n-   Inverse distance weights $w_{i,j} = \\frac{1}{d_{ij}^\\alpha}$, where $\\alpha$ define the strength of the spatial decay.\n\n$$\n\\boldsymbol{\\mathbf{W}} = \\begin{bmatrix} \n            0 & \\frac{1}{d_{ij}^\\alpha} & \\frac{1}{d_{ij}^\\alpha}  \\\\\n\\frac{1}{d_{ij}^\\alpha} & 0 & \\frac{1}{d_{ij}^\\alpha}  \\\\\n\\frac{1}{d_{ij}^\\alpha} & \\frac{1}{d_{ij}^\\alpha} & 0  \n\\end{bmatrix}   \\nonumber\n$$\n\n-   Dense matrices\n\n-   Specifying thresholds may be useful (to get rid of very small non-zero weights)\n\nFor now, we will just specify a neighbours list with a distance threshold of 3km using `dnearneigh()`. An alternative would be k nearest neighbours using `knearneigh()`. We will do the inverse weighting later.\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-7_6f485697e30b5b667eff6f1fa06e4b65'}\n\n```{.r .cell-code}\n# Crease centroids\ncoords <- st_geometry(st_centroid(msoa.spdf))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: st_centroid assumes attributes are constant over geometries\n```\n:::\n\n```{.r .cell-code}\n# Neighbours within 3km distance\ndist_3.nb <- dnearneigh(coords, d1 = 0, d2 = 3000)\nsummary(dist_3.nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 983 \nNumber of nonzero links: 22086 \nPercentage nonzero weights: 2.285652 \nAverage number of links: 22.46796 \n2 disjoint connected subgraphs\nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \n 4  3  7 13 11 14 14 17 26 22 26 30 33 34 46 34 59 43 38 30 25 19 22 15 21 14 \n27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \n23 17 17 23 28 19 26 24 29 24 27 25 22 18  8 10 12  5  3  2  1 \n4 least connected regions:\n158 160 463 959 with 1 link\n1 most connected region:\n545 with 47 links\n```\n:::\n\n```{.r .cell-code}\n# Lets plot that\nplot(st_geometry(msoa.spdf), border = \"grey60\")\nplot(dist_3.nb, coords, \n     add = TRUE, pch = 19, cex = 0.6)\n```\n\n::: {.cell-output-display}\n![](03_weights_files/figure-pdf/unnamed-chunk-7-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nAnd you can see that the matrix is not so sparse anymore:\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-8_a678220c713c4664dcbd45547fa7c8e8'}\n\n```{.r .cell-code}\nW2 <- nb2mat(dist_3.nb, style = \"B\")\nW2[1:10, 1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n1     0    0    0    0    0    0    0    0    0     0\n2     0    0    1    0    1    0    0    0    0     0\n3     0    1    0    0    1    1    1    0    0     0\n4     0    0    0    0    1    1    1    0    1     1\n5     0    1    1    1    0    1    1    1    1     1\n6     0    0    1    1    1    0    1    1    1     1\n7     0    0    1    1    1    1    0    1    1     1\n8     0    0    0    0    1    1    1    0    1     0\n9     0    0    0    1    1    1    1    1    0     1\n10    0    0    0    1    1    1    1    0    1     0\n```\n:::\n:::\n\n\n\n\n## Normalization of ${\\boldsymbol{\\mathbf{W}}}$\n\nNormalizing ensures that the parameter space of the spatial multiplier is restricted to $-1 < \\rho > 1$, and the multiplier matrix is non-singular (don't worry, more on this later). \n\nThe main message: Normalizing your weights matrix is always a good idea. Otherwise, the spatial parameters might blow up -- if you can estimate the model at all. It also ensure easy interpretation of spillover effects.\n\nAgain, how to normalize a weights matrix is subject of debate [@LeSage.2014a; @Neumayer.2016].\n\n### Row-normalization\n\nRow-normalization divides each non-zero weight by the sum of all weights of unit $i$, which is the sum of the row.\n\n$$\n\\frac{w_{ij}}{\\sum_j^n w_{ij}}\n$$\n\n-   With contiguity weights, spatially lagged variables contain mean of this variable among the neighbours of $i$\n\n-   Proportions between units such as distances get lost (can be bad!)\n\n-   Can induce asymmetries: $w_{ij} \\neq w_{ji}$\n\nFor instance, we can use row-normalization for the Queens neighbours created above, and create a neighbours list with spatial weights.\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-9_9bff364d3468e298eab637ffa1c52d30'}\n\n```{.r .cell-code}\nqueens.lw <- nb2listw(queens.nb,\n                      style = \"W\") # W ist row-normalization\nsummary(queens.lw)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 983 \nNumber of nonzero links: 5648 \nPercentage nonzero weights: 0.5845042 \nAverage number of links: 5.745677 \nLink number distribution:\n\n  2   3   4   5   6   7   8   9  10  11  12  13 \n  9  39 130 264 273 169  66  19   5   6   2   1 \n9 least connected regions:\n160 270 475 490 597 729 755 778 861 with 2 links\n1 most connected region:\n946 with 13 links\n\nWeights style: W \nWeights constants summary:\n    n     nn  S0       S1      S2\nW 983 966289 983 355.1333 4017.47\n```\n:::\n:::\n\n\n\nTo see what happened, let's look at our example in matrix format again.\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-10_cdd4000a64c2add7469f1ec179fe441a'}\n\n```{.r .cell-code}\n# transform into matrix with row-normalization\nW_norm <- nb2mat(queens.nb, style = \"W\")\nprint(W_norm[1:10, 1:10])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]      [,8]\n1     0 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000\n2     0 0.0000000 0.1666667 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000\n3     0 0.1428571 0.0000000 0.0000000 0.1428571 0.0000000 0.0000000 0.0000000\n4     0 0.0000000 0.0000000 0.0000000 0.0000000 0.2000000 0.0000000 0.0000000\n5     0 0.0000000 0.2000000 0.0000000 0.0000000 0.2000000 0.2000000 0.0000000\n6     0 0.0000000 0.0000000 0.1666667 0.1666667 0.0000000 0.1666667 0.0000000\n7     0 0.0000000 0.0000000 0.0000000 0.1666667 0.1666667 0.0000000 0.1666667\n8     0 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.1666667 0.0000000\n9     0 0.0000000 0.0000000 0.0000000 0.0000000 0.1666667 0.1666667 0.0000000\n10    0 0.0000000 0.0000000 0.2000000 0.0000000 0.2000000 0.0000000 0.0000000\n        [,9]     [,10]\n1  0.0000000 0.0000000\n2  0.0000000 0.0000000\n3  0.0000000 0.0000000\n4  0.0000000 0.2000000\n5  0.0000000 0.0000000\n6  0.1666667 0.1666667\n7  0.1666667 0.0000000\n8  0.0000000 0.0000000\n9  0.0000000 0.1666667\n10 0.2000000 0.0000000\n```\n:::\n:::\n\n\n\n::: callout-tip\n## Question\n\nOverall, how many neighbours does unit 9 have (including all columns)? How do you know?\n:::\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-11_b0d408b64ecde4be0adfc66dc71db25d'}\n\n```{.r .cell-code}\nrowSums(W)[9]\n```\n:::\n\n\n\nWe can also use the nb object to see    which ones the neighbours are. Here, for instance, neighbours of unit 6:\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-12_efe7bae963dd4fd04963cfd3638b9222'}\n\n```{.r .cell-code}\nqueens.nb[6]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1]   4   5   7   9  10 462\n```\n:::\n:::\n\n\n\nThis fits to what we see in the matrix above.\n\n::: callout-warning\nNote that row-normalization has some undesirable properties when we use some non-contigutiy based neighbour relations, such as distance based neighbours.\n\nThe problem: It obscures the proportion due to dividing by a row-specific value.\n:::\n\nLet's construct a hypothetical example\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-13_ff968d69f7428d202ec4a90cb568f8f3'}\n\n```{.r .cell-code}\n# Subset of 5 units\nsub.spdf <- msoa.spdf[c(4, 5, 6, 102, 150), ]\nmapview(sub.spdf)\n```\n\n::: {.cell-output-display}\n![](03_weights_files/figure-pdf/unnamed-chunk-13-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nWe construct the __inverse-distance weighted 2 nearest neighbors__.\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-14_2d1a9a0b3b6bde423dd88e8bcac1dfea'}\n\n```{.r .cell-code}\n# 2 closest neighbours\nsub.coords <- st_geometry(st_centroid(sub.spdf))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: st_centroid assumes attributes are constant over geometries\n```\n:::\n\n```{.r .cell-code}\nknn.nb <- knearneigh(sub.coords, \n                     k = 2) # number of nearest neighbours\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in knearneigh(sub.coords, k = 2): k greater than one-third of the\nnumber of data points\n```\n:::\n\n```{.r .cell-code}\nknn.nb <- knn2nb(knn.nb)\nsummary(knn.nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 5 \nNumber of nonzero links: 10 \nPercentage nonzero weights: 40 \nAverage number of links: 2 \nNon-symmetric neighbours list\nLink number distribution:\n\n2 \n5 \n5 least connected regions:\n1 2 3 4 5 with 2 links\n5 most connected regions:\n1 2 3 4 5 with 2 links\n```\n:::\n\n```{.r .cell-code}\n# listw with inverse-distance based weights\nsub.lw <- nb2listwdist(knn.nb,\n                       x = sub.coords, # needed for idw\n                       type = \"idw\", # inverse distance weighting\n                       alpha = 1, # the decay parameter for distance weighting\n                       style = \"raw\") # without normalization\nW_sub <- listw2mat(sub.lw)\nformatC(W_sub, format = \"f\", digits = 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [,1]       [,2]       [,3]       [,4]       [,5]      \n1 \"0.000000\" \"0.000414\" \"0.000723\" \"0.000000\" \"0.000000\"\n2 \"0.000414\" \"0.000000\" \"0.000962\" \"0.000000\" \"0.000000\"\n3 \"0.000723\" \"0.000962\" \"0.000000\" \"0.000000\" \"0.000000\"\n4 \"0.000000\" \"0.000033\" \"0.000032\" \"0.000000\" \"0.000000\"\n5 \"0.000049\" \"0.000000\" \"0.000049\" \"0.000000\" \"0.000000\"\n```\n:::\n:::\n\n\n\nAs you can see, units 1, 2, 3 have relatively proximate neighbours (.e.g inverse distance 0.000962: 3 zeros). Units 4 and 5, in contrast, have only very distant neighbours (e.g. inverse distance 0.000049: 4 zeros).\n\nNow, see what happens when we use row-normalization.\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-15_f14898eabea2217736c35b29ff86ae8c'}\n\n```{.r .cell-code}\nsub.lw <- nb2listwdist(knn.nb,\n                       x = sub.coords, # needed for idw\n                       type = \"idw\", # inverse distance weighting\n                       alpha = 1, # the decay parameter for distance weighting\n                       style = \"W\") # for row normalization\nW_sub <- listw2mat(sub.lw)\nformatC(W_sub, format = \"f\", digits = 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [,1]       [,2]       [,3]       [,4]       [,5]      \n1 \"0.000000\" \"0.364083\" \"0.635917\" \"0.000000\" \"0.000000\"\n2 \"0.300879\" \"0.000000\" \"0.699121\" \"0.000000\" \"0.000000\"\n3 \"0.429123\" \"0.570877\" \"0.000000\" \"0.000000\" \"0.000000\"\n4 \"0.000000\" \"0.507955\" \"0.492045\" \"0.000000\" \"0.000000\"\n5 \"0.499360\" \"0.000000\" \"0.500640\" \"0.000000\" \"0.000000\"\n```\n:::\n:::\n\n\n\nAll rows sum up to 1, but the strength of the relation is now similar for the distant units 4 and 5, and the proximate units 1, 2, 3.\n\n### Maximum eigenvalues normalization\n\nMaximum eigenvalues normalization divides each non-zero weight by the overall maximum eigenvalue $\\lambda_{max}$. Each element of $\\boldsymbol{\\mathbf{W}}$ is divided by the same scalar parameter, which preserves the relations.\n\n$$\n\\frac{\\boldsymbol{\\mathbf{W}}}{\\lambda_{max}}\n$$\n\n-   Interpretation may become more complicated\n\n-   Keeps proportions of connectivity strengths across units (relevant esp. for distance based $\\boldsymbol{\\mathbf{W}}$)\n\nWe use eigenvalue normalization for the inverse distance neighbours. We use `nb2listwdist()` to create weight inverse distance based weights and normalize in one step.\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-16_75d28b287db238dafe0396ab99725af5'}\n\n```{.r .cell-code}\ncoords <- st_geometry(st_centroid(msoa.spdf))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: st_centroid assumes attributes are constant over geometries\n```\n:::\n\n```{.r .cell-code}\nidw.lw <- nb2listwdist(dist_3.nb,\n                       x = coords, # needed for idw\n                       type = \"idw\", # inverse distance weighting\n                       alpha = 1, # the decay parameter for distance weighting\n                       style = \"minmax\") # for eigenvalue normalization\nsummary(idw.lw)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 983 \nNumber of nonzero links: 22086 \nPercentage nonzero weights: 2.285652 \nAverage number of links: 22.46796 \n2 disjoint connected subgraphs\nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \n 4  3  7 13 11 14 14 17 26 22 26 30 33 34 46 34 59 43 38 30 25 19 22 15 21 14 \n27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \n23 17 17 23 28 19 26 24 29 24 27 25 22 18  8 10 12  5  3  2  1 \n4 least connected regions:\n158 160 463 959 with 1 link\n1 most connected region:\n545 with 47 links\n\nWeights style: minmax \nWeights constants summary:\n         n     nn       S0       S1       S2\nminmax 983 966289 463.6269 23.92505 1117.636\n```\n:::\n:::\n\n\n\nExamples from above: See how this keeps the proportions in our example. Instead of transforming values to sum up to 1 in each row, we now have much smaller values for 4 and 5 then we have for the proximate units 1, 2, 3.\n\n\n\n::: {.cell hash='03_weights_cache/pdf/unnamed-chunk-17_576477a2a2812161aa5887c0e88da594'}\n\n```{.r .cell-code}\nsub.lw <- nb2listwdist(knn.nb,\n                       x = sub.coords, # needed for idw\n                       type = \"idw\", # inverse distance weighting\n                       alpha = 1, # the decay parameter for distance weighting\n                       style = \"minmax\") # for eigenvalue normalization\nW_sub <- listw2mat(sub.lw)\nformatC(W_sub, format = \"f\", digits = 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [,1]       [,2]       [,3]       [,4]       [,5]      \n1 \"0.000000\" \"0.245687\" \"0.429123\" \"0.000000\" \"0.000000\"\n2 \"0.245687\" \"0.000000\" \"0.570877\" \"0.000000\" \"0.000000\"\n3 \"0.429123\" \"0.570877\" \"0.000000\" \"0.000000\" \"0.000000\"\n4 \"0.000000\" \"0.019663\" \"0.019047\" \"0.000000\" \"0.000000\"\n5 \"0.029099\" \"0.000000\" \"0.029174\" \"0.000000\" \"0.000000\"\n```\n:::\n:::\n\n\n\n\n## Islands / missings\n\nIn practice, we often have a problem with islands. If we use contiguity based or distance based neighbour definitions, some units may end up with empty neighbours sets: they just do not touch any other unit and do not have a neighbour within a specific distance. This however creates a problem: what is the value in the neighbouring units?\n\nThe `zero.policy` option in `spdep` allows to proceed with empty neighbours sets. However, many further functions may run into problems and return errors. It often makes sense to either drop islands, to choose weights which always have neighbours (e.g. k nearest), or impute empty neighbours sets by using the nearest neighbours.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}